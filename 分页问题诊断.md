# 分页问题诊断指南

## 🐛 问题描述
切换分页后数据没有更新

## 🔍 可能的原因

### 1. 前端问题
- **数据绑定问题**: `currentPageData` 计算属性可能有问题
- **状态更新问题**: `pagination.value.page` 更新后没有触发重新请求
- **API 调用问题**: 分页参数没有正确传递到 API

### 2. 后端问题
- **分页参数解析问题**: 后端没有正确解析 `page` 和 `pageSize` 参数
- **数据库查询问题**: 分页查询没有正确执行
- **响应数据问题**: 返回的分页数据不正确

### 3. 缓存问题
- **浏览器缓存**: 浏览器缓存了 API 响应
- **Docker 缓存**: 容器缓存了旧版本

## 🛠️ 诊断步骤

### 步骤 1: 使用调试页面
1. 访问 `http://localhost/debug`
2. 查看当前状态信息
3. 点击测试按钮，观察控制台日志
4. 检查数据是否正确更新

### 步骤 2: 检查控制台日志
打开浏览器开发者工具，查看控制台输出：
- 翻页时是否有 `🔄 翻页到第 X 页` 日志
- API 调用时是否有 `📡 API 查询参数` 日志
- API 响应时是否有 `✅ API 响应成功` 日志

### 步骤 3: 检查网络请求
1. 打开开发者工具 → Network 标签
2. 点击分页按钮
3. 查看是否有新的 API 请求
4. 检查请求参数和响应数据

### 步骤 4: 检查后端日志
```bash
# 查看后端容器日志
docker-compose logs backend

# 实时查看日志
docker-compose logs -f backend
```

## 🔧 解决方案

### 方案 1: 修复前端数据绑定
如果 `currentPageData` 有问题，确保它直接使用 `schools.value`：

```typescript
const currentPageData = computed(() => {
  return schools.value
})
```

### 方案 2: 强制刷新数据
在 `goToPage` 方法中添加强制刷新：

```typescript
const goToPage = async (page: number) => {
  if (page < 1 || page > pagination.value.totalPages) return
  
  pagination.value.page = page
  
  // 强制刷新数据
  if (searchKeyword.value) {
    await searchSchools(searchKeyword.value)
  } else {
    await fetchSchools()
  }
}
```

### 方案 3: 清理缓存
```bash
# 清理 Docker 缓存
docker-compose down -v
docker-compose up -d --build

# 清理浏览器缓存
# Chrome: Ctrl+Shift+R
# Firefox: Ctrl+Shift+R
# Safari: Cmd+Option+R
```

### 方案 4: 检查 API 参数
确保 API 请求包含正确的分页参数：

```typescript
const apiQuery = {
  page: pagination.value.page,
  pageSize: pagination.value.pageSize,
  // ... 其他参数
}
```

## 🧪 测试用例

### 测试 1: 基本分页
1. 访问首页
2. 点击第2页
3. 检查数据是否更新
4. 点击第3页
5. 检查数据是否更新

### 测试 2: 搜索分页
1. 在搜索框输入关键词
2. 点击搜索
3. 点击第2页
4. 检查搜索结果是否正确分页

### 测试 3: 类型切换分页
1. 切换到小学
2. 点击第2页
3. 切换到中学
4. 点击第2页
5. 检查数据是否正确

## 📝 调试信息收集

如果问题仍然存在，请收集以下信息：

1. **浏览器控制台日志**
2. **网络请求详情**
3. **后端日志**
4. **当前分页状态**
5. **API 响应数据**

## 🚀 快速修复

如果急需修复，可以尝试以下快速方案：

```typescript
// 在 goToPage 方法中添加延迟
const goToPage = async (page: number) => {
  if (page < 1 || page > pagination.value.totalPages) return
  
  pagination.value.page = page
  
  // 添加小延迟确保状态更新
  await new Promise(resolve => setTimeout(resolve, 100))
  
  if (searchKeyword.value) {
    await searchSchools(searchKeyword.value)
  } else {
    await fetchSchools()
  }
}
```
