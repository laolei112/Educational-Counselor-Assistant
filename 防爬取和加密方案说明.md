# 防爬取和数据加密方案说明

## 📋 方案概述

本方案实现了多层次的防爬取和数据保护机制，包括：

1. **请求签名验证** - 确保请求来自可信客户端
2. **时间戳验证** - 防止重放攻击
3. **频率限制** - 限制请求频率，防止暴力爬取
4. **反爬虫检测** - 识别常见爬虫工具
5. **设备指纹** - 追踪和识别客户端
6. **HTTPS加密** - 传输层加密

## 🏗️ 架构设计

```
┌─────────────┐
│   客户端     │
│ (浏览器)     │
└──────┬──────┘
       │ 1. 生成签名 (timestamp + nonce + params + secret)
       │ 2. 添加请求头 (X-Api-Key, X-Timestamp, X-Nonce, X-Signature)
       ▼
┌─────────────┐
│   HTTPS      │ ← SSL/TLS加密传输
└──────┬──────┘
       │
       ▼
┌─────────────────────────────────────────┐
│          Nginx (反向代理)                │
│  - HTTPS终止                            │
│  - 证书管理                             │
└──────┬──────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────┐
│     Django中间件（多层防护）              │
│                                         │
│  1. RateLimitMiddleware                 │
│     └─ 检查请求频率                      │
│     └─ IP/设备指纹限制                   │
│                                         │
│  2. AntiCrawlerMiddleware               │
│     └─ User-Agent检测                   │
│     └─ 行为模式识别                      │
│                                         │
│  3. SignatureMiddleware                 │
│     └─ 验证API签名                       │
│     └─ 时间戳验证                        │
│     └─ Nonce防重放                      │
│                                         │
└──────┬──────────────────────────────────┘
       │
       ▼ (通过所有验证)
┌─────────────┐
│  API View   │
│  处理业务逻辑 │
└─────────────┘
```

## 🔐 核心功能详解

### 1. 请求签名机制

#### 签名算法
```
signature = SHA256(timestamp + nonce + apiKey + sortedParams + requestBody + apiSecret)
```

#### 前端实现
- 文件位置：`frontend/src/utils/crypto.ts`
- 每次请求自动生成签名
- 添加签名相关请求头

#### 后端验证
- 文件位置：`backend/backend/middleware/SignatureMiddleware.py`
- 验证签名完整性
- 检查时间戳有效性（默认5分钟窗口）
- 防止nonce重复（防重放攻击）

#### 关键请求头
```http
X-Api-Key: web-client-v1          # 客户端标识
X-Timestamp: 1697366400           # 请求时间戳
X-Nonce: AbC123XyZ...             # 随机字符串
X-Signature: sha256hash...        # 请求签名
X-Device-Id: base64deviceinfo     # 设备指纹
```

### 2. 频率限制

#### 配置参数
- **默认限制**：100次请求/60秒
- **封禁时长**：超限后封禁120秒
- **识别方式**：设备ID > IP地址

#### 响应头
```http
X-RateLimit-Limit: 100            # 总限额
X-RateLimit-Remaining: 45         # 剩余次数
X-RateLimit-Reset: 60             # 重置时间（秒）
Retry-After: 120                  # 被限制时的重试时间
```

#### 自定义配置
修改 `backend/utils/crypto_utils.py`:
```python
rate_limiter = RateLimiter(
    max_requests=200,    # 增加限额到200
    time_window=60       # 时间窗口60秒
)
```

### 3. 反爬虫检测

#### 检测规则

1. **User-Agent黑名单**
   - bot, crawl, spider, scrapy
   - python-requests, curl, wget
   - headless, selenium, puppeteer
   - 等常见爬虫工具

2. **行为检测（严格模式）**
   - 缺少User-Agent
   - User-Agent过于简单
   - 缺少Accept请求头
   - 缺少Accept-Language

3. **白名单**
   - 允许搜索引擎爬虫（Googlebot, Bingbot等）

#### 检测模式
修改 `backend/backend/middleware/AntiCrawlerMiddleware.py`:
```python
DETECTION_MODE = 'moderate'  # 或 'strict'
```

### 4. 设备指纹

#### 生成方式
基于以下信息生成唯一标识：
- User-Agent
- 语言设置
- 时区偏移
- 屏幕分辨率
- 颜色深度

#### 用途
- 跨会话追踪用户
- 配合频率限制
- 异常行为检测

## ⚙️ 配置指南

### 前端配置

#### 1. 创建环境变量文件
创建 `frontend/.env` 文件：
```bash
# API密钥（必须与后端一致）
VITE_API_SECRET=your-secret-key-change-in-production
VITE_API_KEY=web-client-v1
```

#### 2. 密钥管理
- **开发环境**：可以使用默认密钥
- **生产环境**：必须修改为强密钥

生成强密钥示例：
```bash
# Linux/Mac
openssl rand -base64 32

# 或使用Python
python3 -c "import secrets; print(secrets.token_urlsafe(32))"
```

### 后端配置

#### 1. 设置环境变量
在 `docker-compose.yml` 或系统环境中设置：
```yaml
environment:
  - API_SECRET=your-secret-key-change-in-production
```

或直接修改 `backend/utils/crypto_utils.py`：
```python
def __init__(self, secret_key: str = None, valid_api_keys: list = None):
    self.secret_key = secret_key or 'your-custom-secret-key'
    self.valid_api_keys = valid_api_keys or ['web-client-v1']
```

#### 2. 调整中间件开关
在各中间件文件中可以临时禁用：

**SignatureMiddleware.py:**
```python
ENABLE_SIGNATURE_CHECK = False  # 禁用签名验证（调试用）
```

**RateLimitMiddleware.py:**
```python
ENABLE_RATE_LIMIT = False  # 禁用频率限制（调试用）
```

**AntiCrawlerMiddleware.py:**
```python
ENABLE_ANTI_CRAWLER = False  # 禁用反爬虫检测（调试用）
```

#### 3. 白名单配置
如果有特定路径不需要保护，添加到白名单：

```python
# 在各中间件中修改
WHITELIST_PATHS = [
    '/api/health',
    '/nginx-health',
    '/swagger/',
    '/admin/',
    '/api/public/',  # 添加公开路径
]
```

#### 4. 频率限制调整
生产环境建议使用Redis存储：

安装依赖：
```bash
pip install redis
```

修改 `backend/utils/crypto_utils.py`，使用Redis存储：
```python
import redis

class RateLimiter:
    def __init__(self):
        self.redis_client = redis.Redis(
            host='localhost',
            port=6379,
            db=0,
            decode_responses=True
        )
```

## 🚀 部署步骤

### 1. 前端部署

```bash
cd frontend

# 1. 设置环境变量
cat > .env << EOF
VITE_API_SECRET=your-production-secret-key-here
VITE_API_KEY=web-client-v1
EOF

# 2. 安装依赖
npm install

# 3. 构建
npm run build

# 4. 构建Docker镜像
docker build -t edu-frontend .
```

### 2. 后端部署

```bash
cd backend

# 1. 设置环境变量
export API_SECRET="your-production-secret-key-here"

# 2. 安装依赖
pip install -r requirements.txt

# 3. 构建Docker镜像
docker build -t edu-backend .
```

### 3. 使用Docker Compose部署

```bash
# 1. 更新docker-compose.yml，添加环境变量
# 2. 启动服务
docker-compose up -d

# 3. 查看日志
docker-compose logs -f backend
```

## 🧪 测试验证

### 1. 测试正常请求

```bash
# 使用浏览器访问应该正常工作
curl -X GET https://yourdomain.com/api/schools/primary \
  -H "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
```

### 2. 测试签名验证

```bash
# 无签名请求应该被拒绝（403）
curl -X GET https://yourdomain.com/api/schools/primary

# 响应：
# {"code": 403, "message": "签名验证失败: 缺少必要的签名参数", "success": false}
```

### 3. 测试频率限制

```bash
# 快速发送100+请求
for i in {1..110}; do
  curl https://yourdomain.com/api/schools/primary
done

# 第101个请求应返回429
# {"code": 429, "message": "请求过于频繁...", "success": false}
```

### 4. 测试反爬虫

```bash
# 使用爬虫User-Agent应该被拒绝
curl -X GET https://yourdomain.com/api/schools/primary \
  -H "User-Agent: python-requests/2.28.0"

# 响应：
# {"code": 403, "message": "访问被拒绝", "success": false}
```

### 5. 查看日志

```bash
# 查看后端日志中的防护记录
tail -f backend/log/backend.log | grep -E "(签名验证|频率限制|检测到爬虫)"
```

## 📊 监控和分析

### 日志示例

```
INFO 2024-10-15 10:30:15 签名验证失败: 无效的API Key, Path: /api/schools, IP: 192.168.1.100
INFO 2024-10-15 10:30:20 频率限制触发: 请求过于频繁, Client: ip:192.168.1.101, Path: /api/schools
INFO 2024-10-15 10:30:25 检测到爬虫访问: 匹配爬虫特征: scrapy, IP: 192.168.1.102, User-Agent: scrapy/2.8.0
```

### 分析被拦截的请求

```bash
# 统计被拦截的IP
grep "签名验证失败\|频率限制\|爬虫" backend/log/backend.log | \
  grep -oP "IP: \K[0-9.]+" | sort | uniq -c | sort -rn

# 统计爬虫类型
grep "检测到爬虫" backend/log/backend.log | \
  grep -oP "User-Agent: \K[^,]+" | sort | uniq -c | sort -rn
```

## 🔧 故障排查

### 问题1：前端请求全部失败（403）

**原因**：前后端密钥不一致

**解决**：
1. 检查前端 `.env` 文件中的 `VITE_API_SECRET`
2. 检查后端环境变量 `API_SECRET`
3. 确保两者完全一致

### 问题2：正常用户被误拦截

**原因**：检测规则过于严格

**解决**：
1. 修改 `AntiCrawlerMiddleware.py`
   ```python
   DETECTION_MODE = 'moderate'  # 从strict改为moderate
   ```
2. 或临时禁用反爬虫检测
   ```python
   ENABLE_ANTI_CRAWLER = False
   ```

### 问题3：开发时频繁触发频率限制

**原因**：开发时请求频率高

**解决**：
1. 临时禁用频率限制
   ```python
   ENABLE_RATE_LIMIT = False
   ```
2. 或增加限额
   ```python
   rate_limiter = RateLimiter(max_requests=1000, time_window=60)
   ```

### 问题4：时间戳验证失败

**原因**：服务器时间不同步

**解决**：
```bash
# 同步服务器时间
ntpdate -u pool.ntp.org

# 或安装NTP服务
apt-get install ntp
systemctl start ntp
```

## 🔒 安全建议

### 1. 密钥管理

- ✅ **必须**：生产环境使用强随机密钥
- ✅ **必须**：通过环境变量传递密钥，不要硬编码
- ✅ **必须**：定期轮换密钥
- ✅ **建议**：前后端密钥使用密钥管理服务（如AWS KMS）

### 2. HTTPS配置

- ✅ **必须**：生产环境强制使用HTTPS
- ✅ **必须**：使用有效的SSL证书（推荐Let's Encrypt）
- ✅ **建议**：启用HSTS（已配置）
- ✅ **建议**：使用TLS 1.2+（已配置）

### 3. 监控告警

- ✅ **建议**：设置日志监控，及时发现异常
- ✅ **建议**：统计拦截率，评估防护效果
- ✅ **建议**：定期审查白名单和黑名单

### 4. 数据保护

- ✅ **建议**：敏感数据加密存储
- ✅ **建议**：限制单次返回的数据量
- ✅ **建议**：实现数据脱敏

### 5. 应急响应

- ✅ **必须**：准备快速禁用开关
- ✅ **建议**：准备IP黑名单功能
- ✅ **建议**：准备验证码后备方案

## 📈 性能影响

### 预期影响

| 功能 | 延迟增加 | CPU占用 | 内存占用 |
|------|---------|---------|----------|
| 签名验证 | ~2-5ms | 低 | 低 |
| 频率限制 | ~1ms | 低 | 中（内存缓存） |
| 反爬虫检测 | ~1ms | 低 | 低 |
| **总计** | **~5-10ms** | **低** | **中** |

### 优化建议

1. **使用Redis存储频率限制数据**
   - 减少内存占用
   - 支持分布式部署
   - 更可靠的持久化

2. **缓存签名验证结果**
   - 短时间内相同请求不重复验证
   - 权衡安全性和性能

3. **异步日志记录**
   - 使用异步日志避免阻塞
   - 定期归档历史日志

## 🆘 技术支持

### 相关文件

**前端：**
- `frontend/src/utils/crypto.ts` - 加密和签名工具
- `frontend/src/api/request.ts` - HTTP请求封装

**后端：**
- `backend/utils/crypto_utils.py` - 签名验证和频率限制
- `backend/backend/middleware/SignatureMiddleware.py` - 签名验证中间件
- `backend/backend/middleware/RateLimitMiddleware.py` - 频率限制中间件
- `backend/backend/middleware/AntiCrawlerMiddleware.py` - 反爬虫中间件
- `backend/backend/basic_settings.py` - 中间件配置

### 调试技巧

1. **查看请求头**
   ```javascript
   // 在浏览器控制台
   console.log('Request Headers:', xhr.getAllResponseHeaders());
   ```

2. **测试签名生成**
   ```python
   # 在Django shell中
   from utils.crypto_utils import signature_validator
   is_valid, msg = signature_validator.validate_signature(
       timestamp='1697366400',
       nonce='test123',
       api_key='web-client-v1',
       signature='...',
       params={'page': '1'}
   )
   print(f"Valid: {is_valid}, Message: {msg}")
   ```

3. **监控请求**
   ```bash
   # 实时查看被拦截的请求
   tail -f backend/log/backend.log | grep -E "(403|429)"
   ```

## 📝 更新记录

- **2024-10-15**
  - ✅ 实现请求签名机制
  - ✅ 实现频率限制
  - ✅ 实现反爬虫检测
  - ✅ 配置HTTPS支持
  - ✅ 完善文档

---

## ⚠️ 重要提示

1. **生产环境部署前必须修改密钥**
2. **建议先在测试环境验证所有功能**
3. **定期检查日志，优化拦截规则**
4. **保持防护机制和业务需求的平衡**

